<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.64.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Adam Hartleb</title><link rel="stylesheet" href="/css/core.min.3d2ce6cbea745ca5e44b1f033f9f76347756723f72cbf8309703e3a7a915de7995a8e15f07535317a2cdde891e32c936.css" integrity="sha384-PSzmy&#43;p0XKXkSx8DP592NHdWcj9yy/gwlwPjp6kV3nmVqOFfB1NTF6LN3okeMsk2"><link rel="alternate" type="application/rss+xml" href="/index.xml" title="Adam Hartleb" /><body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Adam Hartleb</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/tags/">Tags</a></nav></div></span></div></section><div id="content"><ul class="note list"><li class="item"><a class="note" href="/post/intro-to-cpp-types/">
            <p class="note title">Intro to C++ - Types</p><p class="note date">Friday, March 13, 2020</p><p class="note content">We&rsquo;ll be investigating the primitive types C++ has to offer in this post and reference types in the following post.
Integers The Integer type store whole numbers and come in four sizes: short int, int, long int, long long int. In addition, each type can be signed (negative whole numbers permitted) or unsigned (only positive numbers).
A short is typically 2 bytes in size and an int is 4 bytes. A long is 4 bytes on everything except on 64-bit Linxu/macOS where it is 8 bytes.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/cpp/">cpp</a><a class="tag" href="/tags/intro/">intro</a></p></li><li class="item"><a class="note" href="/post/intro-to-cpp/">
            <p class="note title">Intro to C++ - Getting Started</p><p class="note date">Tuesday, March 10, 2020</p><p class="note content">To begin, we write human-redable C++ code in a source file which is then compiled to produce machine code that our computers can run. Here&rsquo;s an example of a minimal source file:
// main.cpp#include &lt;cstdio&gt;int main() {printf(&quot;Hello, World!&quot;);return 0;}The above declares a function called main which serves as an entry point to our program, after all, the program has to stat somewhere. Within our main function we call another function printf which prints the text to the terminal.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/cpp/">cpp</a><a class="tag" href="/tags/intro/">intro</a></p></li><li class="item"><a class="note" href="/post/intro-to-rust-collections/">
            <p class="note title">Intro to Rust - Collections</p><p class="note date">Friday, March 6, 2020</p><p class="note content">Collections are data structures that contain multiple values. However, unlike arrays and tuples that are stored on the stack, these types are stored on the heap.
Vectors Vectors are similar to arrays except they can grow dynamically. Like an array, it can only store a single data type. To a create a new vector, we write:
let a: Vec&lt;u32&gt; = Vec::new();The type annotation above is necessary as we&rsquo;ve created an empty vector so Rust has nothing to infer from.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/rust/">rust</a><a class="tag" href="/tags/intro/">intro</a></p></li><li class="item"><a class="note" href="/post/intro-to-machine-learning/">
            <p class="note title">Intro to Machine Learning</p><p class="note date">Thursday, March 5, 2020</p><p class="note content">Machine learning is the field of study that gives a computer the ability to learn without being explicitly programmed.
As an example, the spam filter from your email provider can learn and analyze what emails are being reported as spam and then apply that filter before the email even reaches you. If we were to program this manually, we might use regular expressions to search for certain keywords we provide in the email and feed each email that comes in through that algorithm.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/intro/">intro</a><a class="tag" href="/tags/machine-learning/">machine learning</a></p></li><li class="item"><a class="note" href="/post/cs-namespaces/">
            <p class="note title">C# Namespaces</p><p class="note date">Wednesday, March 4, 2020</p><p class="note content">In large programs or if you&rsquo;re using third-party libraries, you&rsquo;ll often encounter types with the same name as your own. In order to avoid such naming collisions, you can namespace your types. A namespace is simply a grouping of related code under a single name.
In our previous articles on C#, you&rsquo;ll notice we used:
using System;Console.WriteLine(&quot;Hello&quot;);However, this isn&rsquo;t the fully qualified name for the WriteLine method. The full name is System.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/csharp/">csharp</a></p></li><li class="item"><a class="note" href="/post/intro-to-rust-structs/">
            <p class="note title">Intro to Rust - Structs</p><p class="note date">Tuesday, March 3, 2020</p><p class="note content">A struct is a data type that allows you to group multiple related values under a single type. To define a struct in Rust, we use the struct keyword:
struct Point {x: i32,y: i32,}And we create an instance of the struct like so:
let p = Point{ x: 3, y: 4 };And to access a field on the struct we use dot notation:
println!(&quot;x: {}, y: {}&quot;, p.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/rust/">rust</a><a class="tag" href="/tags/intro/">intro</a></p></li><li class="item"><a class="note" href="/post/intro-to-rust-ownership/">
            <p class="note title">Intro to Rust - Ownership</p><p class="note date">Monday, March 2, 2020</p><p class="note content">Every programming language has to have some way to manage the memory it consumes while the program is running. In higher level languages like JavaScript this is managed with a garbage collector or with lower level languages like C, the memory is allocated and freed manually. Rust uses a different approach with a concept known as ownership.
Stack and Heap The stack and heap are parts of memory that your program can utilize at runtime.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/rust/">rust</a><a class="tag" href="/tags/intro/">intro</a></p></li><li class="item"><a class="note" href="/post/cs-generics/">
            <p class="note title">C# Generics</p><p class="note date">Sunday, March 1, 2020</p><p class="note content">Imagine that you created a method that accepts an array of numbers and loops over them and writes the value at each index to the console. Now imagine you wanted similar functionality, but applied to an array of doubles, strings or booleans. Now, you can&rsquo;t use your original method because it only accepts numbers so you have two alterntives:
 You could create a method that does the same thing for each type.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/csharp/">csharp</a></p></li><li class="item"><a class="note" href="/post/cs-interfaces/">
            <p class="note title">C# Interfaces</p><p class="note date">Thursday, February 27, 2020</p><p class="note content">An interface defines a contract that specifies what methods a class must implement in order to satisfy that contract. Any class that implements an interface is guaranteed to have those methods or the code will not compile. Creating an interface is similar to creating a class or a struct:
public interface IFileReader {void Read(string filename);}As you probably notice, the interface does not implement the method, it only declares it.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/csharp/">csharp</a></p></li><li class="item"><a class="note" href="/post/intro-to-rust-variables/">
            <p class="note title">Intro to Rust - Variables</p><p class="note date">Wednesday, February 26, 2020</p><p class="note content">Variables are conceptually labeled boxes that we can store values. The box is the address in memory where the value is stored and the label is just a human readable alias for that address.
All variable declarations in Rust start with the let keyword followed by the name we assign to variable. Here we are declaring a variable called z and assigning the value 12 to it:
let z = 12;By default, all variables in Rust are immutable meaning you cannot re-assign a value to them.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/rust/">rust</a><a class="tag" href="/tags/intro/">intro</a></p></li></ul><div class="pagination">
    <ul><li><a class="active" href="/">1</a></li><li><a class="" href="/page/2/">2</a></li></ul>
</div></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">Â©2020 Adam Hartleb.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section></div>
</body>

</html>