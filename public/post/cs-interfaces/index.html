<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.64.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>C# Interfaces&nbsp;&ndash;&nbsp;Adam Hartleb</title><link rel="stylesheet" href="/css/core.min.3d2ce6cbea745ca5e44b1f033f9f76347756723f72cbf8309703e3a7a915de7995a8e15f07535317a2cdde891e32c936.css" integrity="sha384-PSzmy&#43;p0XKXkSx8DP592NHdWcj9yy/gwlwPjp6kV3nmVqOFfB1NTF6LN3okeMsk2"><body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Adam Hartleb</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/tags/">Tags</a></nav></div></span></div></section><div id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">C# Interfaces</h1><p class="article date">Thursday, February 27, 2020</p></section><article class="article markdown-body"><p>An interface defines a contract that specifies what methods a class must implement in order to satisfy that contract. Any class that implements an interface is guaranteed to have those methods or the code will not compile. Creating an interface is similar to creating a class or a struct:</p>
<pre><code>public interface IFileReader {
  void Read(string filename);
}
</code></pre><p>As you probably notice, the interface does not implement the method, it only declares it. This is similar to how abstract classes work. So why use an interface if an abstract class will do or vice versa?</p>
<ol>
<li>
<p>You can inherit from multiple interfaces, but you can only inherit from one class.</p>
</li>
<li>
<p>Abstract classes still allow you to implement methods while interfaces do not.</p>
</li>
<li>
<p>Abstract classes represent an &ldquo;is-a&rdquo; relationship so it&rsquo;s used for objects that are closely related. Interfaces represent a &ldquo;can-do&rdquo; relationship and is used for providing common functionality to unrelated classes.</p>
</li>
</ol>
<p>To implement an interface, we use a colon like inheritance:</p>
<pre><code>class Reader : IFileReader
{
  public string FileType { get; }

  public void Read(string filename)
  {
    // ...
  }
}
</code></pre><p>Similar to classes and structs, they can be treated as types so you can have an array of them:</p>
<pre><code>IFileReader[] readers = new IFileReader[5];
</code></pre><p>Or you can accept them as an argument to a method:</p>
<pre><code>public void doSomething(IFileReader r)
{
  // ...
}
</code></pre><p>To implement multiple interfaces, you just add a comma after the first:</p>
<pre><code>class Reader : IFileReader, AnotherInterface, Interface3
{
  // ...
}
</code></pre></article><section class="article labels"><a class="tag" href=/tags/csharp/>csharp</a></section></div><section class="article navigation"><p><a class="link" href="/post/cs-generics/"><span class="li">&larr;</span>C# Generics</a></p><p><a class="link" href="/post/intro-to-rust-variables/"><span class="li">&rarr;</span>Intro to Rust - Variables</a></p></section></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">Â©2020 Adam Hartleb.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section></div>
</body>

</html>