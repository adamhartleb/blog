<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.64.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>csharp&nbsp;&ndash;&nbsp;Adam Hartleb</title><link rel="stylesheet" href="/css/core.min.3d2ce6cbea745ca5e44b1f033f9f76347756723f72cbf8309703e3a7a915de7995a8e15f07535317a2cdde891e32c936.css" integrity="sha384-PSzmy&#43;p0XKXkSx8DP592NHdWcj9yy/gwlwPjp6kV3nmVqOFfB1NTF6LN3okeMsk2"><link rel="alternate" type="application/rss+xml" href="/tags/csharp/index.xml" title="Adam Hartleb" /><body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Adam Hartleb</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/tags/">Tags</a></nav></div></span></div></section><div id="content"><section class="article header"><h1>csharp</h1></section><ul class="note list"><li class="item"><a class="note" href="/post/cs-namespaces/">
            <p class="note title">C# Namespaces</p><p class="note date">Wednesday, March 4, 2020</p><p class="note content">In large programs or if you&rsquo;re using third-party libraries, you&rsquo;ll often encounter types with the same name as your own. In order to avoid such naming collisions, you can namespace your types. A namespace is simply a grouping of related code under a single name.
In our previous articles on C#, you&rsquo;ll notice we used:
using System;Console.WriteLine(&quot;Hello&quot;);However, this isn&rsquo;t the fully qualified name for the WriteLine method. The full name is System.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/csharp/">csharp</a></p></li><li class="item"><a class="note" href="/post/cs-generics/">
            <p class="note title">C# Generics</p><p class="note date">Sunday, March 1, 2020</p><p class="note content">Imagine that you created a method that accepts an array of numbers and loops over them and writes the value at each index to the console. Now imagine you wanted similar functionality, but applied to an array of doubles, strings or booleans. Now, you can&rsquo;t use your original method because it only accepts numbers so you have two alterntives:
 You could create a method that does the same thing for each type.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/csharp/">csharp</a></p></li><li class="item"><a class="note" href="/post/cs-interfaces/">
            <p class="note title">C# Interfaces</p><p class="note date">Thursday, February 27, 2020</p><p class="note content">An interface defines a contract that specifies what methods a class must implement in order to satisfy that contract. Any class that implements an interface is guaranteed to have those methods or the code will not compile. Creating an interface is similar to creating a class or a struct:
public interface IFileReader {void Read(string filename);}As you probably notice, the interface does not implement the method, it only declares it.<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/csharp/">csharp</a></p></li><li class="item"><a class="note" href="/post/cs-structs/">
            <p class="note title">C# Structs</p><p class="note date">Thursday, February 20, 2020</p><p class="note content">Structs and Classes are constructed very similarly in C#:
struct Book{private string title;private int[] editions;public string Title{get { return title; }set { title = value; }}public string Author { get; set; }public int[] Editions{get { return editions; }set { editions = value; }}public string Blurb(){return $&quot;{Title} by {Author}&quot;;}}And they are instantiated in the same way:<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/csharp/">csharp</a></p></li><li class="item"><a class="note" href="/post/cs-autoimplemented-props/">
            <p class="note title">C# Autoimplemented Properties</p><p class="note date">Wednesday, February 19, 2020</p><p class="note content">In object-oriented programming, you&rsquo;ll often be creating getters and setters for instance variables. For example:
class Book{private string title;public Book(string title){this.title = title;}GetTitle(){return title;}SetTitle(string title){this.title = title;}}The problem with this is that it&rsquo;s verbose and creating getters and setters is extremely common so it becomes a little cumbersome. Now, you might be thinking &ldquo;If I can just freely get and set the instance variable, why not make its accessibility public?<span class="mldr">&mldr;more</span></p></a><p class="note labels"><a class="tag" href="/tags/csharp/">csharp</a></p></li></ul></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">Â©2020 Adam Hartleb.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section></div>
</body>

</html>